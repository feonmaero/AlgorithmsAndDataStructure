
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>
/*Анна Зубкова*/
/* *3. **Исполнитель «Калькулятор» преобразует целое число, записанное на экране. У
исполнителя две команды, каждой присвоен номер:
1. Прибавь 1.
2. Умножь на 2.
Первая команда увеличивает число на экране на 1, вторая увеличивает его в 2 раза. Сколько
существует программ, которые число 3 преобразуют в число 20:
а. С использованием массива.
b. *С использованием рекурсии.*/

//Основная мысль: 1) получаем ряд чисел для вычисления количества программ для перехода от первого числа к конечному
//(в примере - от 3 к 20)
//2) затем, рассматривая каждое число в отдельности, выводим формулу для прохода от первого числа к четному
//и от первого числа к нечетному
//например, пройти от 3 к 6 можно 2мя способами, а от 3 к 5 одним
//Составляем формулы расчетов количества путей в зависимости от четности числа:
//Конечное число четное: Количество путей предыдущего + Количество путей текущего деленного на 2
//Конечное число нечетное: Количество путей предыдущего

//1) Решение через массивы. Задается 2 массива, 1 хранит сами числа, другой - количество путей для каждого из них
int progamountarr(int x, int y)
{
	int m=(y-x)+1;//получить число элементов в массиве
	int arr[m];//массив под последовательность чисел
	int b[m];//массив под количество путей
	b[0]=1;//для начала последовательно количество путей всегда 1
	arr[0]=x; //задать начало поелсдовательности
	int i;
	int half=2; //задала начальное значение, это некоторая дельта для последующих вычислений. обычно значение 0
	b[half]=0;
	int k;
	for (i=1;i<=m-1;i++)
	{
		arr[i]=arr[i-1]+1;
	}

	for (i=1;i<m;i++)
	{
		if (arr[i]%2==0)
		{
			for (k=0;k<=m;k++)
			{
				if (arr[k]==arr[i]/2)
				{
					half=k;
					b[i]=b[i-1]+b[half];

				}
			}
			if (b[half]==0)
			{
				b[i]=b[i-1];
			}
		}
		else
		{
			b[i]=b[i-1];
		}
	}
	printf("Количество путей %d \n", b[m-1]);
	return 0;
}


/*1. Реализовать функцию перевода из 10 системы в двоичную используя рекурсию.*/
long int dvoi(int x)
{
    if (x/2==0)
    {
        return x%2;
    }
    return dvoi(x/2)*10 + x%2;
}
/*2. Реализовать функцию возведения числа a в степень b:
a. без рекурсии;
a и b целые натуральные числа*/
void degreenorec(long int a, int b)
{
	int i=1;
	int f=a;
	if (b!=0)
	{
	while (i<b)
	{
		a=a*f;
		i++;
	}
	printf("Возведение в степень (без рек.): %ld \n", a);
	}
	if (a==0 & b==0)
	{
		printf("Возведение в степень (без рек.): неопределенность \n");
	}
	if (b==0 & a!=0)
	{
		a=1;
		printf("Возведение в степень (без рек.): %ld \n", a);
	}
}
/*b. рекурсивно;*/
long int degreewithrec(long int a, int b)
{
     if (b==0 & a!=0)
     {
    	 return 1;
     }
     if (a==0 & b==0)
     {
    	 printf("Возведение в степень (рек.): неопределенность \n");
    	 return 0;
     }
     else
     {
    	 return a*degreewithrec(a, b-1);
     }
}

int main()
{
	progamountarr(3, 20);
    long int x=dvoi(33);
    printf("Перевод из десятичной в двоичную: %ld \n", x);
    degreenorec(8, 3);
    printf("Полученное значение от возведения в степень (рек.): %ld \n", degreewithrec(6, 5));
	return 0;
}
